# Week 4 Planning Summary

**Date**: December 24, 2025
**Status**: ‚úÖ **PLANNING COMPLETE**

## What We Planned

### 1. QEMU Execution Loop

Designed complete execution control matching UAE's API:

**Functions to implement:**
- `Start680x0_QEMU()` - Main execution loop (never returns)
- `Execute68k_QEMU()` - Execute subroutine, return when done
- `Execute68kTrap_QEMU()` - Execute Mac OS trap
- `TriggerInterrupt_QEMU()` - Trigger level 1 interrupt
- Updated EmulOp hook to handle `M68K_EXEC_RETURN` (0x7100)

**Key design decisions:**
- Mirror UAE's `quit_program` flag mechanism
- Use QEMU's `cpu_exec()` for block execution
- Handle interrupts via `cpu_interrupt()` API
- Proper stack manipulation for Execute68k/Trap

### 2. DualCPU Testing Harness

Designed side-by-side execution framework for empirical validation:

**Core concept:**
```
UAE CPU (proven) ‚îÄ‚îÄ‚îê
                   ‚îú‚îÄ‚Üí Execute same code ‚Üí Compare states
QEMU CPU (test) ‚îÄ‚îÄ‚îÄ‚îò
```

**Execution modes:**
- **Lockstep** - Compare every instruction (slow, precise)
- **Periodic** - Compare every N instructions (balanced)
- **Checkpoint** - Compare at specific PCs (fast, coarse)
- **Trace** - Record traces, compare offline (fastest)

**CPUSnapshot structure:**
- PC, D0-D7, A0-A7, SR, USP/SSP
- Instruction count, last opcode
- ~56 bytes per snapshot

**API functions:**
- `DualCPU_Init()` / `DualCPU_Exit()`
- `DualCPU_ExecuteOne()` - Run both CPUs, compare
- `DualCPU_Compare()` - State comparison
- `DualCPU_SnapshotUAE()` / `DualCPU_SnapshotQEMU()`

## Documentation Created

- **[WEEK4_EXECUTION_AND_DUALCPU_DESIGN.md](WEEK4_EXECUTION_AND_DUALCPU_DESIGN.md)** (514 lines)
  - Complete design specifications
  - Code examples for all functions
  - Testing strategy
  - Performance analysis
  - Implementation checklist

## Implementation Roadmap

### Week 4: Execution Loop
1. Implement `Start680x0_QEMU()` main loop
2. Implement `Execute68k_QEMU()` subroutine execution
3. Implement `Execute68kTrap_QEMU()` trap handling
4. Update EmulOp hook for M68K_EXEC_RETURN
5. Test with simple program (MOVE/ADD/RTS)

**Estimated effort:** 2-3 days

### Week 5: DualCPU Harness
1. Create `dualcpu_harness.cpp` skeleton
2. Implement CPUSnapshot structure
3. Implement snapshot functions for UAE and QEMU
4. Implement comparison logic
5. Test lockstep mode with simple instructions

**Estimated effort:** 3-4 days

### Week 6: DualCPU Modes
1. Implement periodic mode
2. Implement checkpoint mode
3. Implement trace mode with compression
4. Performance optimization
5. Integration with preferences system

**Estimated effort:** 2-3 days

## Key Insights from Research

### UAE CPU Architecture
- `Start680x0()` is the main loop (never returns)
- `m68k_execute()` runs interpreter loop
- `m68k_compile_execute()` runs JIT loop
- EmulOps handled in `m68k_emulop()` callback
- `M68kRegisters` structure bridges UAE ‚Üî BasiliskII
- Stack manipulation for Execute68k/Trap (push return addr + EXEC_RETURN)

### QEMU CPU Integration Points
- `cpu_exec()` - Main execution function (returns on exception/interrupt)
- `cpu_reset()` - Reset CPU state
- `cpu_interrupt()` - Trigger interrupt
- Exception codes: `EXCP_INTERRUPT`, `EXCP_HLT`, etc.
- Reset vectors at ROM+0 (SP) and ROM+4 (PC)

### DualCPU Innovation
This is **THE KEY** to making QEMU migration tractable:
- Without it: "Months of fucking around" debugging subtle differences
- With it: Instant pinpoint detection of divergences with full context
- Enables binary search to find exact instruction where divergence occurs

## Testing Strategy

### Phase 1: Simple Execution (Week 4)
```asm
MOVE.W #$1234,D0    ; Load immediate
MOVE.W #$5678,D1    ; Load immediate
ADD.W  D1,D0        ; Add
RTS                 ; Return
```
Expected: D0 = 0x68AC

### Phase 2: DualCPU Validation (Week 5)
Run Phase 1 test with DualCPU in lockstep - verify identical execution at every step.

### Phase 3: Instruction Sweep (Weeks 6-8)
Comprehensive m68k instruction validation with DualCPU.

## Files to Create

```
qemu-cpu/
‚îú‚îÄ‚îÄ dualcpu_harness.h       # DualCPU API
‚îú‚îÄ‚îÄ dualcpu_harness.cpp     # DualCPU implementation
‚îî‚îÄ‚îÄ cpu_snapshot.h          # Snapshot structures

test/
‚îú‚îÄ‚îÄ test_execution.cpp      # Execution loop tests
‚îî‚îÄ‚îÄ test_dualcpu.cpp        # DualCPU tests

docs/qemu/
‚îú‚îÄ‚îÄ WEEK4_EXECUTION_AND_DUALCPU_DESIGN.md  # Complete design (this)
‚îî‚îÄ‚îÄ WEEK4_SUMMARY.md                       # This summary
```

## Files to Modify

```
qemu-cpu/qemu_m68k_adapter.cpp   # Add execution functions
BasiliskII/src/main.cpp          # DualCPU init
BasiliskII/src/prefs.cpp         # DualCPU preferences
```

## Performance Impact

| Configuration | Overhead | Use Case |
|--------------|----------|----------|
| QEMU only | 0% | Production (post-validation) |
| DualCPU Checkpoint | ~10% | Boot validation |
| DualCPU Periodic | ~30% | General validation |
| DualCPU Lockstep | ~150% | Divergence debugging |

## Next Actions

**Immediate (Week 4):**
1. Start implementing `Start680x0_QEMU()` in [qemu-cpu/qemu_m68k_adapter.cpp](../../qemu-cpu/qemu_m68k_adapter.cpp)
2. Add `quit_program` extern declaration
3. Implement basic execution loop with `cpu_exec()`
4. Test with minimal program

**Then (Week 5):**
1. Create DualCPU harness files
2. Implement lockstep mode
3. Run first dual-execution test
4. Celebrate when both CPUs match! üéâ

**After (Week 6+):**
1. Add advanced DualCPU modes
2. Performance optimization
3. Full instruction set validation
4. ROM boot testing

## Success Metrics

**Week 4 Success:**
- ‚úÖ QEMU can execute simple m68k program
- ‚úÖ Start680x0_QEMU() runs without crashing
- ‚úÖ Execute68k_QEMU() returns correct results
- ‚úÖ EmulOp hook handles M68K_EXEC_RETURN

**Week 5 Success:**
- ‚úÖ DualCPU harness compiles and runs
- ‚úÖ UAE and QEMU execute identical simple program
- ‚úÖ Snapshot/compare functions work correctly
- ‚úÖ Divergence detection triggers properly

**Week 6 Success:**
- ‚úÖ All DualCPU modes implemented
- ‚úÖ Performance acceptable (lockstep < 3x overhead)
- ‚úÖ Ready for instruction set validation

## Current Project Status

**Completed:**
- ‚úÖ Week 1: QEMU integration (submodule, build, patches)
- ‚úÖ Week 2: Illegal instruction hooks
- ‚úÖ Week 3: Memory integration (zero-copy)
- ‚úÖ Week 4 Planning: Execution loop & DualCPU design

**Ready to implement:**
- üìã Week 4: Execution loop implementation
- üìã Week 5: DualCPU harness
- üìã Week 6: Advanced DualCPU modes

**Timeline:**
- Original estimate: 16 weeks total
- Current pace: On track (4 weeks of planning/foundation complete)
- Remaining: 12 weeks (execution, validation, optimization)

## References

- [Week 3 Memory Integration](WEEK3_MEMORY_INTEGRATION.md)
- [QEMU Migration Summary](QEMU_MIGRATION_SUMMARY.md)
- [DualCPU Testing Approach](DUALCPU_TESTING_APPROACH.md)
- [Implementation Roadmap](IMPLEMENTATION_ROADMAP.md)

---

**Status**: Ready to move from planning to implementation! üöÄ
