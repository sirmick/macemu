From: MacEmu Project <macemu@example.com>
Date: Tue, 24 Dec 2024 00:20:00 +0000
Subject: [PATCH 1/2] m68k: Add illegal instruction hook for BasiliskII EmulOps

BasiliskII and SheepShaver use illegal MOVEQ instructions in the 0x71xx
range as "EmulOps" - special opcodes that trap to the emulator for device
emulation (video, disk, network, etc.).

This patch adds a simple hook that allows external code to intercept these
opcodes before the normal illegal instruction exception is raised.

The hook is checked during exception processing, where we still have access
to the opcode that caused the exception.

Signed-off-by: MacEmu Project <macemu@example.com>
---
 target/m68k/cpu.h       |  4 ++++
 target/m68k/op_helper.c | 14 ++++++++++++++
 2 files changed, 18 insertions(+)

diff --git a/target/m68k/cpu.h b/target/m68k/cpu.h
index 1234567890..abcdef1234 100644
--- a/target/m68k/cpu.h
+++ b/target/m68k/cpu.h
@@ -579,4 +579,8 @@ static inline int cpu_mmu_index(CPUM68KState *env, bool ifetch)

 void m68k_cpu_list(void);

+/* Hook for external illegal instruction handler (BasiliskII/SheepShaver EmulOps) */
+/* Returns true if handled, false if normal illegal instruction exception should occur */
+extern bool (*m68k_illegal_insn_hook)(CPUM68KState *env, uint16_t opcode);
+
 #endif
diff --git a/target/m68k/op_helper.c b/target/m68k/op_helper.c
index 9876543210..fedcba9876 100644
--- a/target/m68k/op_helper.c
+++ b/target/m68k/op_helper.c
@@ -25,6 +25,9 @@
 #include "semihosting/semihost.h"
 #include "qemu/plugin.h"

+/* External illegal instruction hook (NULL by default) */
+bool (*m68k_illegal_insn_hook)(CPUM68KState *env, uint16_t opcode) = NULL;
+
 #if !defined(CONFIG_USER_ONLY)

 static void cf_rte(CPUM68KState *env)
@@ -401,6 +404,17 @@ static void m68k_interrupt_all(CPUM68KState *env, int is_hw)
         break;

     case EXCP_ILLEGAL:
+        /* Check for external hook (BasiliskII/SheepShaver EmulOps) */
+        if (m68k_illegal_insn_hook != NULL) {
+            /* Read the opcode that caused the illegal instruction exception */
+            uint16_t opcode = cpu_lduw_code(env, env->pc);
+
+            /* Call the hook - if it returns true, it handled the opcode */
+            if (m68k_illegal_insn_hook(env, opcode)) {
+                /* Hook handled it, skip exception processing and continue */
+                return;
+            }
+        }
         do_stack_frame(env, &sp, 0, oldsr, 0, env->pc);
         break;

--
2.34.1
